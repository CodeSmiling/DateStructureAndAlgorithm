# 链表
### 目录

* [两数之和](#两数之和)
* [合并两个有序链表](#合并两个有序链表)
* [k个一组翻转链表](#k个一组翻转链表)
---
### 两数之和
Q:给出两个**非空**的链表用来表示两个非负的整数。其中，它们各自的位数是按照**逆序**的方式存储的，并且它们的每个节点只能存储**一位**数字。

我们将这两个数相加起来，则会返回一个新的链表表示它们的和。假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

A:遍历两个链表进行相加：1.如果链表长度不一样，值为null则等于0。
                      2.涉及到进位问题，如果两数之和>10,则记录进位值，实际值取余。
                      3.最后一位如果为0，则需要补1，或者是进位值不为0。
```java
  public LinkedNode addTwoNumber(LinkedNode l1,LinkedNode l2){
        //建立一个链表用于记录返回的头结点
        LinkedNode pre=new LinkedNode(0);
        LinkedNode cur=pre;
        //用于标记进位的值 
        int carry=0;
        while(l1!=null||l2!=null){
            int x=l1==null?0:l1.val;
            int y=l2==null?0:l2.val;
            //此时要加进位的值
            int sum=x+y+carry;
            carry=sum/10;
            sum=sum%10;
            cur.next=new LinkedNode(sum);
            cur=cur.next;
            if(l1!=null) l1=l1.next;
            if(l2!=null) l2=l2.next;
        }
        //表明此时还有进位的值
        if(carry==1){
            cur.next=new LinkedNode(1);
        }
        return pre.next;
    }
```
### 合并两个有序链表
Q:将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

A:采用双指针，比较两个指针的指向值的大小
```java
 public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //新建一个节点
         ListNode pre=new ListNode(-1);
         //作为遍历的头节点
         ListNode cur=pre;
         //当两个链表都不为空的时候
        while (l1!=null&&l2!=null){
            //按照升序的方式进行排列
            if(l1.val<=l2.val){
                cur.next=l1;
                l1=l1.next;
            }
           else{
               cur.next=l2;
               l2=l2.next;
            }
        }
        //遍历的主链表也需要往后移
        cur.next=l1==null?l2:l1;
        return pre.next;
    }
```
---
### K个一组翻转链表
Q:给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

A:链表的画图工作特别重要

https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/
```java
 public ListNode reverseKGroup(ListNode head, int k) {
        //新建一个头结点
        ListNode dummy=new ListNode(0);
        dummy.next=head;
        //用于标记k个节点内的头节点和尾节点
        ListNode pre=dummy;
        ListNode end=dummy;

        //循环找到k个节点
        //因为end需要遍历下个节点，所以先检查下end.next是否存在
        while(end.next!=null){
            for(int i=0;i<k&&end!=null;i++){
                end=end.next;
            }
            if(end==null) break;
            ListNode start=pre.next;
            /**
             *  将前面k个节点断开
             *  1.先标记end节点的下一个节点next
             *  2.将end节点最后一个节点设置为null
             */
            ListNode next=end.next;
            end.next=null;
            //前面k个节点进行翻转
            pre.next=reverse(start);
            //start节点下一个变为next
            start.next=next;
            //将pre和end都设置为上一个链节的最后一个节点
            pre=start;
            end=pre;
        }
        return dummy.next;
    }

    //将头结点传入
    private ListNode reverse(ListNode head) {
        ListNode pre=null;
        ListNode cur=head;
        //此时是需要cur节点不为null
        while(cur!=null){
            ListNode temp=cur.next;
            cur.next=pre;
            pre=cur;
            cur=temp;
        }
        return pre;
    }
```

