# 链表
### 目录

* [两数之和](#两数之和)
* [合并两个有序链表](#合并两个有序链表)

---
### 两数之和
Q:给出两个**非空**的链表用来表示两个非负的整数。其中，它们各自的位数是按照**逆序**的方式存储的，并且它们的每个节点只能存储**一位**数字。

我们将这两个数相加起来，则会返回一个新的链表表示它们的和。假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

A:遍历两个链表进行相加：1.如果链表长度不一样，值为null则等于0。
                      2.涉及到进位问题，如果两数之和>10,则记录进位值，实际值取余。
                      3.最后一位如果为0，则需要补1，或者是进位值不为0。
```java
  public LinkedNode addTwoNumber(LinkedNode l1,LinkedNode l2){
        //建立一个链表用于记录返回的头结点
        LinkedNode pre=new LinkedNode(0);
        LinkedNode cur=pre;
        //用于标记进位的值 
        int carry=0;
        while(l1!=null||l2!=null){
            int x=l1==null?0:l1.val;
            int y=l2==null?0:l2.val;
            //此时要加进位的值
            int sum=x+y+carry;
            carry=sum/10;
            sum=sum%10;
            cur.next=new LinkedNode(sum);
            cur=cur.next;
            if(l1!=null) l1=l1.next;
            if(l2!=null) l2=l2.next;
        }
        //表明此时还有进位的值
        if(carry==1){
            cur.next=new LinkedNode(1);
        }
        return pre.next;
    }
```
### 合并两个有序链表
Q:将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
示例：

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

A:采用双指针，比较两个指针的指向值的大小
```java
 public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        //新建一个节点
         ListNode pre=new ListNode(-1);
         //作为遍历的头节点
         ListNode cur=pre;
         //当两个链表都不为空的时候
        while (l1!=null&&l2!=null){
            //按照升序的方式进行排列
            if(l1.val<=l2.val){
                cur.next=l1;
                l1=l1.next;
            }
           else{
               cur.next=l2;
               l2=l2.next;
            }
        }
        //遍历的主链表也需要往后移
        cur.next=l1==null?l2:l1;
        return pre.next;
    }
```

