# 动态规划

## 目录

- [最长公共子串](#最长公共子串)
- [最长回文子串](#最长回文子串)
- [最大子序和](#最大子序和)
- [最大正方形](#最大正方形)
- [乘积最大子数组](#乘积最大子数组)
---
### 最长公共子串
Q:两个字符串中最长连续相同的子串的长度
A:求子串长度N与M，生成一个N*M的数组dp，用di[i][j]来表示数组str1[0..i]与str2[0..j]的长度
```java
 public  int maxLengthOfsubString(String s1,String s2){
        char[] char1=s1.toCharArray();
        char[] char2=s2.toCharArray();
        int m=char1.length+1;int n=char2.length+1;
        int[][] arr=new int[m][n];
        int res=0;
        for(int i=0;i<char1.length;i++){
            for(int j=0;j<char2.length;j++){
                if(char1[i]==char2[j]){
                    arr[i+1][j+1]=arr[i][j]+1;
                    res= Math.max(res,arr[i+1][j+1]);
                }
            }
        }
        return res;
    }
```
---
### 最长回文子串
- 题目连接：https://leetcode-cn.com/problems/longest-palindromic-substring/
- 思路
动态规划：核心步骤dp[i][j]=dp[i+1][j-1]&&s[i]==s[j]
- tip：边界条件，j - i < 3才可以使用上述递推条件

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

```java
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
		if(len < 2){
			return s;
		}
		int maxLen = 1;
		int begin = 0;
		boolean[][] dp = new boolean[len][len];
		for(int i = 0; i < len; i++){
			dp[i][i] = true;
		}
		for(int j = 1; j < len; j++){
			for(int i = 0; i < j; i++){
				if(s.charAt(i) == s.charAt(j)){
					if(j - i < 3){
						dp[i][j] = true;
					}
					else{
                        dp[i][j] = dp[i + 1][j - 1];
                    }
				}
				else{
					dp[i][j] = false;
				}
                if(dp[i][j] && j - i + 1 > maxLen){
					maxLen = j - i + 1;
					begin = i;
				}
			}
		}
		return s.substring(begin, begin + maxLen);
    }
}
```
---
### 最大子序和
Q:给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

A:返回值只要求一个结果，采用动态规划的思想。如果i-1项和>0,则nums[i]=nums[i-1]+nums[i]，否则nums[i-1]=0;

```java
 public int maxSubArray(int[] nums) {
        //如果数组只有一个值
        int max=nums[0];
        for(int i=1;i<nums.length;i++){
            if(nums[i-1]>=0){
                nums[i]=nums[i-1]+nums[i];
            }else{
               //重置
               nums[i-1]=0;
            }
            max=Math.max(nums[i],max);
        }
        return max;
    }
```

### 最大正方形
Q:在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
 示例:

 输入: 

 1 0 1 0 0
 1 0 1 1 1
 1 1 1 1 1
 1 0 0 1 0

 输出: 4
 A:求最值考虑动态规划，dp[i][j]代表以i,j为右下角正方形的最大边长。之后再检查左上角，左边，上边。
 
 ```java
 public int maximalSquare(char[][] matrix){
        int maxSide=0;
        if(matrix==null||matrix.length==0||matrix[0].length==0) return maxSide;

        int rows=matrix.length;
        int columns=matrix[0].length;
        //二位数组的值代表以当前坐标为右下角的正方形的最大边长
        int[][] dp=new int[rows][columns];

        //开始遍历二维数组
        for(int i=0;i<rows;i++){
            for(int j=0;j<columns;j++){
                if(matrix[i][j]=='1'){
                    //边界1位左边下角，边界为1
                    if(i==0||j==0){
                        dp[i][j]=0;
                    }
                    else {
                        dp[i][j]=Math.min((Math.min(dp[i-1][j],dp[i][j-1])),dp[i-1][j-1])+1;
                    }
                }
                maxSide=Math.max(maxSide,dp[i][j]);

            }
        }
        return maxSide*maxSide;
    }
 ```
### 乘积最大子数组
Q:给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

示例 1:
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。

示例 2:
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

A：采用动态规划的思想。不过数组中包含正数和负数，此时需要分开求最大值和最小值。采用二维数组dp[][0]：最小值，dp[][1]:最大值。
```java
  public int maxProduct(int[] nums){
        int length=nums.length;
        if(length==0) return 0;
        int[][] dp=new int[length][2];
        //dp[i][0]:以nums[i]为结尾最小值
        //dp[i][1]:以nums[i]为结尾最大值
        dp[0][1]=nums[0];
        dp[0][0]=nums[0];

        for(int i=1;i<length;i++){
            if(nums[i]>=0){
                dp[i][0]=Math.min(nums[i],dp[i-1][0]*nums[i]);
                dp[i][1]=Math.max(nums[i],dp[i-1][1]*nums[i]);
            }else {
                dp[i][0]=Math.min(nums[i],dp[i-1][1]*nums[i]);
                dp[i][1]=Math.max(nums[i],dp[i-1][0]*nums[i]);
            }
        }
        //只关心最大值，需要遍历
        int res=dp[0][1];
        for(int i=0;i<length;i++){
            res=Math.max(res,dp[i][1]);
    }
        return res;
}
```


